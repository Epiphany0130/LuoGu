#include <bits/stdc++.h>
 using namespace std;
 int main() {
    //定义两个字符串，分别存放减数和被减数
    string s1, s2;
    //使用 getline 函数对字符串进行输入
    getline(cin, s1);
    getline(cin, s2);
    //定义三个整型数组
    //s1 倒叙存入 a1，并变数字，s2 倒叙存入 a2，并变数组
    //a3 存储各个位相减后的值，倒叙
    int a1[210] = {}, a2[210] = {}, a3[210] = {};
    //一个字符变量存储符号
    char flag = '+';
    //我们需要让数字大的数放在上面（模拟列竖式），如果 s1 长度本身就大于 s2，那就不用变，结果为正数
    //如果 s1 的长度小于 s2 的长度，说明结果为负数，那就让更长的 s2 放在上面，也就是交换 s1 和 s2 的值（保持 s1 永远是更大的数）
    //如果 s1 的长度和 s2 的长度相同，这时没办法通过长度判断出哪个数更大，就要比较字符串
    //字符串是可以直接比较的，如果 s1 < s2 那就说明 s1 的数小于 s2 的数，那就需要交换
    //字符串是可以直接比较的，其原理是通过字典码的比较
    //比如：123 和 122  首先比较 1，两个都是 1 说明字典码相同，那就比较第二个数 2，两个都是 2 说明字典码相同，那就比较第三个数，
    //3 和 2 字典码不同，3 的字典码大于 2 的字典码，所以 123 大于 122
    //同理，这里的 s1 和 s2 也是这样比较
    if(s1.size() < s2.size() || s1.size() == s2.size() && s1 < s2) {
        //如果 s1 的值是小的，那就使用 swap 函数交换两个字符串的值，保证 s1 的值是更大的
        swap(s1, s2);
        //因为 s1 小于 s2，所以相减后的值是负数，那这里 flag 的值就改成负号
        flag = '-';
    }
    //将 s1 的值逆序存储在 a1 中
    for(int i = 0; i < s1.size(); i++) {
        a1[i] = s1[s1.size()-i-1] - '0';
    }
    //将 s2 的值逆序存储在 a2 中
    for(int i = 0; i < s2.size(); i++) {
        a2[i] = s2[s2.size()-i-1] - '0';
    }
    //进行相减运算
    for(int i = 0; i < s1.size(); i++) {
        //如果运算位 a1 的值小于 a2 的值，说明减不到，就要借位
        if(a1[i] < a2[i]) {
            //向前一位借位 1，本位就是加 10
            a1[i] = a1[i] + 10;
            //前一位被借了1，那就要减去 1
            a1[i+1] = a1[i+1] - 1;
        }
        //把 a1 - a2 的值存储在 a3 中
        a3[i] = a1[i] - a2[i];
    }
    //如果符号是负号，说明是负数，要输出负号
    if(flag == '-') {
        cout << flag;
    }
    //逆序输出结果，也就是 a3 的值
    //但这里有个问题，a3 的大小定义的是 210，但结果大概率不会是 210 位，所以要找到最后一位数的下标位置，从这一位置逆序输出
    //定义一个 index 存储这个位置
    int index = 0;
    //开始找这个位置，从 s1.size() 开始往前找
    //因为 s1 里面存的是大的数，进行减法运算后这个数绝对不会大于 s1.size。举个例子：625 减去任何一个数，它的值都不可能大于三位
    for(int i = s1.size(); i >= 0; i--) {
        //如果数为 0，说明这不是最终结果的第一位，因为逆序输出，一个数的第一位不可能是 0
        //当找到第一个不是 0 的数，说明找到了
        if(a3[i] != 0) {
            //找到这个位置后，把其下标给到 index，然后就可以退出循环了
            index = i;
            break;
        }
    }
    //从 index 的位置开始逆序输出结果
    for(int i = index; i >= 0; i--) {
        cout << a3[i];
    }
    return 0;
 }